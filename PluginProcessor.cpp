/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
PanoramaAudioProcessor::PanoramaAudioProcessor()
{
    //Set starting values for all parameters
    userParams[masterBypass] = 0.0f; //not bypassed
    userParams[pan] = 0.0f; //center pan
    userParams[panLaw] = 3.0f; //standard 3dB pan law
    userParams[panLawEnabled] = 1.0f; //enabled
	userParams[algorithm] = (float) Panorama::EQUAL_POWER; //equal power panning
    
    //Push starting values
    setParameter(pan, userParams[pan]);
    setParameter(panLaw, userParams[panLaw]);
    setParameter(panLawEnabled, userParams[panLawEnabled]);
    setParameter(algorithm, userParams[algorithm]);
}

PanoramaAudioProcessor::~PanoramaAudioProcessor()
{
}

//==============================================================================
const String PanoramaAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int PanoramaAudioProcessor::getNumParameters()
{
    return totalNumParam;
}

float PanoramaAudioProcessor::getParameter (int index)
{
    switch(index) {
        case masterBypass:
            return userParams[masterBypass];
        case pan:
            //Pull pan value and return it
            userParams[pan] = (float) mPanorama.getPan();
            return userParams[pan];
        case panLaw:
            //Pull pan law value and return it
            userParams[panLaw] = mPanorama.getPanLaw();
            return userParams[panLaw];
        case panLawEnabled:
            //Pull pan law enabled value and return it
            if(mPanorama.panLawEnabled()) {
                userParams[panLawEnabled] = 1.0f;
            } else {
                userParams[panLawEnabled] = 0.0f;
            }
            return userParams[panLawEnabled];
        case algorithm:
            //Pull algorithm and return it
            Panorama::Algorithm a = mPanorama.getAlgorithm();
            switch(a) {
                case Panorama::LINEAR_CROSSFADE:
                    userParams[algorithm] = 0.0f;
                    break;
                case Panorama::EQUAL_POWER:
                    userParams[algorithm] = 1.0f;
                    break;
                case Panorama::SPEAKER_TO_SPEAKER:
                    userParams[algorithm] = 2.0f;
                    break;
            }
            return userParams[algorithm];
    }
}

void PanoramaAudioProcessor::setParameter (int index, float newValue)
{
    switch(index) {
        case masterBypass:
            if(newValue == 1.0f) {
                userParams[masterBypass] = 1.0f; //bypassed
            } else {
                userParams[masterBypass] = 0.0f; //not bypassed
            }
            break;
        case pan:
            if(newValue < -100.0f) {
                newValue = -100.0f;
            } else if(newValue > 100.0f) {
                newValue = 100.0f;
            }
            userParams[pan] = newValue;
            mPanorama.setPan((int) userParams[pan]);
            break;
        case panLaw:
            userParams[panLaw] = newValue;
            mPanorama.setPanLaw(userParams[panLaw]);
            break;
        case panLawEnabled:
            if(newValue > 0.0f) {
                userParams[panLawEnabled] = 1.0f;
                mPanorama.setPanLawEnabled(true);
            } else if(newValue <= 0.0f) {
                userParams[panLawEnabled] = 0.0f;
                mPanorama.setPanLawEnabled(false);
            }
            break;
        case algorithm:
            switch((int) newValue) {
                case 0:
                    userParams[algorithm] = newValue;
                    mPanorama.setAlgorithm(Panorama::LINEAR_CROSSFADE);
                    break;
                case 1:
                    userParams[algorithm] = newValue;
                    mPanorama.setAlgorithm(Panorama::EQUAL_POWER);
                    break;
                case 2:
                    userParams[algorithm] = newValue;
                    mPanorama.setAlgorithm(Panorama::SPEAKER_TO_SPEAKER);
                    break;
            }
            break;
    }
    
    requestUIUpdate();
}

const String PanoramaAudioProcessor::getParameterName (int index)
{
    switch(index) {
        case masterBypass:
            return "Bypass";
        case pan:
            return "Pan";
        case panLaw:
            return "Pan Law";
        case panLawEnabled:
            return "Pan Law Enabled";
        case algorithm:
            return "Algorithm";
    }
}

const String PanoramaAudioProcessor::getParameterText (int index)
{
    return String();
}

const String PanoramaAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String PanoramaAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool PanoramaAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool PanoramaAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool PanoramaAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool PanoramaAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool PanoramaAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double PanoramaAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int PanoramaAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int PanoramaAudioProcessor::getCurrentProgram()
{
    return 0;
}

void PanoramaAudioProcessor::setCurrentProgram (int index)
{
}

const String PanoramaAudioProcessor::getProgramName (int index)
{
    return String();
}

void PanoramaAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void PanoramaAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void PanoramaAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void PanoramaAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

    //Check for proper channel configurations and bypass status.
    if(getNumInputChannels() == 2 && !userParams[masterBypass]) {
        //Apply DSP to the incoming audio
        
        //Get pointers to the left and right buffers
        float* leftBuffer = buffer.getWritePointer(0);
        float* rightBuffer = buffer.getWritePointer(1);
        
        //For every sample in these buffers, send it through mPanorama's clockProcess() function.
        long i;
        for(i = 0; i < buffer.getNumSamples(); ++i) {
            mPanorama.clockProcess(&leftBuffer[i], &rightBuffer[i]);
        }
    }
}

//==============================================================================
bool PanoramaAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* PanoramaAudioProcessor::createEditor()
{
    return new PanoramaAudioProcessorEditor (*this);
}

//==============================================================================
void PanoramaAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    
    //Idea sourced from the JUCE demo plugin; original implementation.
    //Hopefully I can create something maintenance-free.
    
    //Create the root XML node/element.
    XmlElement xml("PANORAMASETTINGS");
    
    //Set attributes.
    for(int i = 0; i < totalNumParam; ++i) {
        xml.setAttribute(getParameterName(i), getParameter(i));
    }
    
    //Dump to the given memory block.
    copyXmlToBinary(xml, destData);
}

void PanoramaAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    
    //Code sourced from the JUCE demo plugin with mild modifications.
    
    //Retrieve the XML information
    ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));
    
    //Parse it all out.
    if(xmlState != nullptr) {
        //Make sure that we've got the right data.
        if(xmlState->hasTagName("PANORAMASETTINGS")) {
            //Pull information and push it to our plugin.
            for(int i = 0; i < totalNumParam; ++i) {
                setParameter(i, (float) xmlState->getDoubleAttribute(getParameterName(i), getParameter(i)));
            }
        }
    }
    
    requestUIUpdate();
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new PanoramaAudioProcessor();
}
